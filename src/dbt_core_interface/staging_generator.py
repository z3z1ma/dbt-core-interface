#!/usr/bin/env python
# pyright: reportPrivateImportUsage=false,reportUnknownMemberType=false,reportUnknownVariableType=false
"""Auto staging model generation from sources.

Given database sources, automatically generate staging models with proper column
renaming, type casting, and documentation. Similar to dbt-coves 'generate sources'
command.
"""

from __future__ import annotations

import logging
import re
import typing as t
from dataclasses import dataclass, field
from enum import Enum
from string import Template

if t.TYPE_CHECKING:
    from dbt.contracts.graph.nodes import ManifestNode, SourceDefinition

logger = logging.getLogger(__name__)


class NamingConvention(Enum):
    """Naming conventions for staging model columns."""

    SNAKE_CASE = "snake_case"
    CAMEL_CASE = "camel_case"
    KEBAB_CASE = "kebab_case"
    PASCAL_CASE = "pascal_case"


@dataclass(frozen=True)
class ColumnMapping:
    """A mapping from source column to staging column."""

    source_name: str
    staging_name: str
    data_type: str | None = None
    description: str = ""
    cast_expression: str = ""

    def to_select_sql(self, indent: int = 4) -> str:
        """Generate SELECT statement for this column mapping."""
        indent_str = " " * indent
        if self.cast_expression:
            return f"{indent_str}{self.cast_expression} as {self.staging_name},"
        return f"{indent_str}{self.source_name} as {self.staging_name},"


@dataclass
class StagingModelConfig:
    """Configuration for staging model generation."""

    destination_model: str = ""
    source_name: str = ""
    table_name: str = ""
    materialization: str = "view"
    naming_convention: NamingConvention = NamingConvention.SNAKE_CASE
    remove_prefixes: list[str] = field(default_factory=list)
    remove_suffixes: list[str] = field(default_factory=list)
    add_prefix: str = ""
    add_suffix: str = ""
    dedup_column: str | None = None
    generate_tests: bool = True
    generate_documentation: bool = True
    custom_column_mappings: dict[str, str] = field(default_factory=dict)


class StagingGenerator:
    """Generate staging models from source definitions."""

    # Default SQL template for staging models
    STAGING_MODEL_TEMPLATE = """-- Staging model for ${source_name}.${table_name}
-- Auto-generated by dbt-core-interface
${config_block}

with source as (
    select * from {{ source('${source_name}', '${table_name}') }}
),

renamed as (
    select
${select_columns}
    from source
)

select * from renamed
"""

    # YAML schema template
    YAML_SCHEMA_TEMPLATE = """version: 2

models:
  - name: ${model_name}
    description: "${description}"
    tests:
      - dbt_utils.expression_is_true:
          expression: "COUNT(*) > 0"
${column_tests}
"""

    def __init__(
        self,
        config: StagingModelConfig | None = None,
    ) -> None:
        """Initialize the staging generator.

        Args:
            config: Configuration for staging model generation
        """
        self.config = config or StagingModelConfig()

    def generate_from_source(
        self,
        source: SourceDefinition,
        manifest: t.Any | None = None,
    ) -> dict[str, t.Any]:
        """Generate staging model from a source definition.

        Args:
            source: The source definition node
            manifest: The dbt manifest

        Returns:
            Dictionary with keys:
                - model_name: Suggested model name
                - model_sql: Generated SQL model
                - schema_yml: Generated YAML schema
                - column_mappings: List of column mappings
        """
        # Extract source info
        source_name = source.source_name
        table_name = source.name

        # Generate model name
        model_name = self._generate_model_name(source_name, table_name)

        # Get column mappings
        columns = self._extract_source_columns(source)
        column_mappings = self._generate_column_mappings(columns)

        # Generate SELECT clause
        select_columns = "\n".join(
            cm.to_select_sql() for cm in column_mappings
        )
        # Remove trailing comma from last column
        select_columns = select_columns.rstrip(",")

        # Generate config block
        config_block = self._generate_config_block()

        # Generate SQL model
        model_sql = Template(self.STAGING_MODEL_TEMPLATE).substitute(
            source_name=source_name,
            table_name=table_name,
            config_block=config_block,
            select_columns=select_columns,
        )

        # Generate YAML schema
        schema_yml = self._generate_schema_yml(
            model_name=model_name,
            source_name=source_name,
            table_name=table_name,
            column_mappings=column_mappings,
        )

        return {
            "model_name": model_name,
            "source_name": source_name,
            "table_name": table_name,
            "model_sql": model_sql,
            "schema_yml": schema_yml,
            "column_mappings": [
                {
                    "source_name": cm.source_name,
                    "staging_name": cm.staging_name,
                    "data_type": cm.data_type,
                    "description": cm.description,
                }
                for cm in column_mappings
            ],
        }

    def _generate_model_name(self, source_name: str, table_name: str) -> str:
        """Generate a staging model name from source and table names."""
        # Apply naming convention to table name
        clean_table = self._apply_naming_convention(table_name)
        return f"stg_{clean_table}"

    def _extract_source_columns(self, source: SourceDefinition) -> dict[str, t.Any]:
        """Extract column information from source definition."""
        columns: dict[str, t.Any] = {}
        if hasattr(source, "columns"):
            for col_name, col_info in source.columns.items():
                columns[col_name] = {
                    "name": col_name,
                    "data_type": col_info.get("data_type") if isinstance(col_info, dict) else None,
                    "description": col_info.get("description", "") if isinstance(col_info, dict) else "",
                    "tags": col_info.get("tags", []) if isinstance(col_info, dict) else [],
                    "meta": col_info.get("meta", {}) if isinstance(col_info, dict) else {},
                }
        return columns

    def _generate_column_mappings(
        self,
        columns: dict[str, t.Any],
    ) -> list[ColumnMapping]:
        """Generate column mappings from source columns."""
        mappings: list[ColumnMapping] = []

        for col_name, col_info in columns.items():
            # Check for custom mapping first
            if col_name in self.config.custom_column_mappings:
                staging_name = self.config.custom_column_mappings[col_name]
            else:
                staging_name = self._clean_column_name(col_name)

            # Generate cast expression if data type is known
            cast_expr = self._generate_cast_expression(
                col_name,
                col_info.get("data_type"),
            )

            mappings.append(
                ColumnMapping(
                    source_name=col_name,
                    staging_name=staging_name,
                    data_type=col_info.get("data_type"),
                    description=col_info.get("description", ""),
                    cast_expression=cast_expr,
                )
            )

        return mappings

    def _clean_column_name(self, column_name: str) -> str:
        """Clean and standardize a column name."""
        result = column_name

        # Remove prefixes
        for prefix in self.config.remove_prefixes:
            if result.startswith(prefix):
                result = result[len(prefix):]
                # Remove separator if present
                if result.startswith(("_", "-", " ")):
                    result = result[1:]

        # Remove suffixes
        for suffix in self.config.remove_suffixes:
            if result.endswith(suffix):
                result = result[: -len(suffix)]
                # Remove separator if present
                if result.endswith(("_", "-", " ")):
                    result = result[:-1]

        # Apply naming convention
        result = self._apply_naming_convention(result)

        # Add prefix/suffix if configured
        if self.config.add_prefix:
            result = f"{self.config.add_prefix}_{result}"
        if self.config.add_suffix:
            result = f"{result}_{self.config.add_suffix}"

        return result

    def _apply_naming_convention(self, name: str) -> str:
        """Apply naming convention to a name."""
        convention = self.config.naming_convention

        if convention == NamingConvention.SNAKE_CASE:
            return self._to_snake_case(name)
        elif convention == NamingConvention.CAMEL_CASE:
            return self._to_camel_case(name)
        elif convention == NamingConvention.KEBAB_CASE:
            return self._to_kebab_case(name)
        elif convention == NamingConvention.PASCAL_CASE:
            return self._to_pascal_case(name)
        else:
            return name

    def _to_snake_case(self, name: str) -> str:
        """Convert name to snake_case."""
        # Replace spaces, hyphens, dots with underscores
        name = re.sub(r"[\s\-\.]+", "_", name)
        # Insert underscores before capital letters (for camelCase)
        name = re.sub(r"([a-z])([A-Z])", r"\1_\2", name)
        # Convert to lowercase
        name = name.lower()
        # Remove duplicate underscores
        name = re.sub(r"_+", "_", name)
        # Strip leading/trailing underscores
        name = name.strip("_")
        return name

    def _to_camel_case(self, name: str) -> str:
        """Convert name to camelCase."""
        # First convert to snake_case for processing
        snake = self._to_snake_case(name)
        parts = snake.split("_")
        return parts[0].lower() + "".join(p.capitalize() for p in parts[1:])

    def _to_kebab_case(self, name: str) -> str:
        """Convert name to kebab-case."""
        return self._to_snake_case(name).replace("_", "-")

    def _to_pascal_case(self, name: str) -> str:
        """Convert name to PascalCase."""
        # First convert to snake_case for processing
        snake = self._to_snake_case(name)
        parts = snake.split("_")
        return "".join(p.capitalize() for p in parts)

    def _generate_cast_expression(
        self,
        column_name: str,
        data_type: str | None,
    ) -> str:
        """Generate a type cast expression for a column.

        This is a placeholder - actual implementation would depend on
        database type and desired target type.
        """
        # For now, return empty string (no cast)
        # Future: add intelligent type casting based on source type
        return ""

    def _generate_config_block(self) -> str:
        """Generate the config block for the model."""
        lines = ["{{ config("]
        lines.append(f"    materialized='{self.config.materialization}'")
        if self.config.dedup_column:
            lines.append(f"    unique_key='{self.config.dedup_column}'")
        lines.append(") }}")
        return "\n".join(lines)

    def _generate_schema_yml(
        self,
        model_name: str,
        source_name: str,
        table_name: str,
        column_mappings: list[ColumnMapping],
    ) -> str:
        """Generate YAML schema for the staging model."""
        lines: list[str] = []

        # Description
        description = f"Staging model for {source_name}.{table_name}"

        # Column tests
        column_tests_lines: list[str] = []
        for cm in column_mappings:
            if not self.config.generate_tests:
                continue

            # Determine column tests based on column name patterns
            tests = self._suggest_column_tests(cm.staging_name)
            if not tests:
                continue

            column_tests_lines.append(f"      - name: {cm.staging_name}")
            if self.config.generate_documentation and cm.description:
                column_tests_lines.append(f"        description: \"{cm.description}\"")
            column_tests_lines.append("        tests:")
            for test in tests:
                column_tests_lines.append(f"          - {test}")

        column_tests = "\n".join(column_tests_lines) if column_tests_lines else ""

        return Template(self.YAML_SCHEMA_TEMPLATE).substitute(
            model_name=model_name,
            description=description,
            column_tests=column_tests,
        )

    def _suggest_column_tests(self, column_name: str) -> list[str]:
        """Suggest dbt tests for a column based on its name pattern."""
        tests: list[str] = []
        lower_name = column_name.lower()

        # Primary key patterns
        if lower_name in ("id", "uuid", "guid", "pk") or lower_name.endswith("_id"):
            tests.extend(["unique", "not_null"])

        # Timestamp patterns
        if any(x in lower_name for x in ("created_at", "updated_at", "deleted_at", "timestamp")):
            tests.append("not_null")

        # Email patterns
        if "email" in lower_name:
            tests.append("not_null")

        # Status/state patterns
        if any(x in lower_name for x in ("status", "state", "type")):
            tests.append("not_null")

        # Required field patterns
        if any(x in lower_name for x in ("name", "title", "description")):
            tests.append("not_null")

        return tests


def generate_staging_model_from_source(
    source: SourceDefinition,
    manifest: t.Any | None = None,
    config: StagingModelConfig | None = None,
) -> dict[str, t.Any]:
    """Convenience function to generate a staging model from a source.

    Args:
        source: The source definition node
        manifest: The dbt manifest
        config: Optional configuration for generation

    Returns:
        Dictionary with generated model and schema
    """
    generator = StagingGenerator(config)
    return generator.generate_from_source(source, manifest)


__all__ = [
    "NamingConvention",
    "ColumnMapping",
    "StagingModelConfig",
    "StagingGenerator",
    "generate_staging_model_from_source",
]
